# 스텍, 큐, 덱

> 😎 : 풀었다. 내 풀이가 마음에 든다.
> 😗 : 풀긴 했지만 내 코드가 마음에 안든다.
> 🥲 : 어느정도 아이디어도 생각하고 풀어봤지만 결국 못풀었다.
> 😱 : 너무 어려웠다.

> 2022.02.10

## 😎[스텍](./stack.10828.js)

- 스택을 push pop size empty top 기능을 구현하고 입력된 값을 기능에 맞게 처리하는 함수를 구현했다.
- method를 모아서 method를 활용했다.
- map을 사용했는데 채점을 할 때, map이 동작하지 않아서 반복문으로 바꿨다.

## 🥲[스텍 수열](./stacksequence.1874.js)

- 스택 수열 문제를 읽었지만 이해하기 어려웠다. 1~N만큼 크기를 가진 수열이 있는데 스택 안에 있는 수를 오름 차순으로 뽑아낼 수 있는지 확인하는 문제였다.
- 검증을 할 때 stack에 남아있는 수가 있는지 체크하고 있으면 NO를 출력하는 방법으로 풀었었는데 그럴 필요가 없었다. 그냥 수열이 쌓일 때 오름 차순으로 뽑아 낼 수 없으면 바로 NO를 출력하면 됐다.

## 😎[단어 뒤집기](./word.9093.js)

- 단어 뒤집기가 왜 자료구조 문제인지 잘은 모르겠다.
- map과 reverse를 사용해서 간단하게 정답을 출력했다.

## 🥲[괄호](brakets.9012.js)

- 괄호 문제는 스택 수열과 거의 비슷한 문제였다. 여러번 풀어봤는데 이해를 잘 못한 것인지 여전히 헤맸다.
- 괄호가 ()을 이루면 YES이고 아니면 NO를 출력하면 되는데 stack에서 pop한 자료를 변수에 따로 저장하지 않고도 풀 수 있었다.
- 스택 수열과 다르게 stack안에 값이 남아있을 수 있기 때문에 stack의 길이를 검증해야한다.
- 최종 result의 값이 false이면 NO다.

## 🥲[편집기](./editor.1406.js)

- 요세푸스 수열과 편집기 문제가 가장 재미있었다.
- 스택과 큐를 사용해서 커서의 위치를 정하고 조건에 따라서 문자열을 추가하거나 삭제할 수 있었다.
- 반복문으로 풀면 시간 초과가 난다. 그래서 push, pop을 사용해서 문제를 풀면 통과할 수 있었다.

## 😎[큐](./queue.10845.js)

- 역시 큐의 FIFO을 구현하는 문제였다.

## 🥲[요세푸스 수열](./josephus.1158.js)

- 원을 배열 안에서 구현할 수 있는지 생각해보는 문제였다. 처음에는 for문으로 엄청 복잡하게 풀었는데 나중에 지날수록 디버깅이 어려워졌다.
- push와 shift를 사용해서 앞에 있는 수를 배열에 맨 뒤로 보내는 방법으로 풀 수 있었다.

## 😎[덱](deck.10866.js)

- 덱을 구현하는 문제였다. 덱은 스텍과 큐처럼 LIFO아 FIFO이 둘다 할 수 있었다. 덱은 자료가 들어간 순서와 관계 없이 자료를 뽑아 낼 수 있었다.
- 시간 초과가 날 줄 알았는데 그러지 않았다.

> 2022.02.11

## 😱 [단어 뒤집기 2](./wordbackandfoward.17413.js)

- 단어 뒤집기의 방법은 reverse 함수를 사용하는 방법도 있지만 모든 값을 배열로 쪼갠 다음 변수를 사용해서 문자열을 뒤바꾸는 방법도 있다.

- 예를 들어

```js
const words = "word";
let answer = "";
words.split("").forEach((word) => {
  answer = word + answer;
});
```

이렇게 하면 answer는 drow가 된다.

## 🥲 [쇠막대기](./ironStick.10799.js)

- 한번 풀어봤던건데... ㅜㅜ 또 다시 헤맸다. stack을 사용해서 푸는 문제인데 어느 위치에서 쇠막대기가 시작 되는지를 구현할 수 있어야한다.

## 😎 [오큰수](./ohbignumber.17208.js)

- 이건... 조건에 맞는 값을 단순하게 출력하면 풀수 있는 문제다.

## 😱 [오등큰수](./ohequalbignumber.17299.js)

- 풀긴 풀었는데 메모리 초과다. 다른 사람들의 답을 봤는데... 사실 이해가 잘 안간다. 이런 논리를 생각해낼 수 있다는게 신기하다.
- stack에는 i가 들어간다. i는 0-N개만큼 있다.

```js
while (stack.length && count[arr[stack[stack.lenght - 1]]] < count[arr[i]]) {}
```

스텍은 LIFO다. 나중에 나온 값이 처음에 나간다. 그래서 위 조건을 다시 생각해보면
count[arr[쌓인 값]] < count[arr[i]] 라고 생각할 수 있다. i는 순차적으로 0-N으로 반복되기 때문에 오른쪽 식의 값은 arr[i]의 순서대로 F(arr[i])가 출력된다고 볼 수 있다.

조건에 따른 자료 구조의 모양은 이렇다. (손으로 일일이 다 그려봄 ㅜㅠ )

| i   | stack              | result                      | 스택 NGF | 순차 NGF |
| --- | ------------------ | --------------------------- | -------- | -------- |
| 0   | \[ \]              | \[-1,-1,-1,-1,-1,-1,-1,-1\] | x        | 3        |
| 1   | \[0\]              | \[-1,-1,-1,-1,-1,-1,-1,-1\] | 3        | 3        |
| 2   | \[0, 1\]           | \[-1,-1,-1,-1,-1,-1,-1,-1\] | 3        | 2        |
| 3   | \[0, 1, 2 \]       | \[-1,-1,-1,-1,-1,-1,-1,-1\] | 2        | 1        |
| 4   | \[0, 1, 2, 3 \]    | \[-1,-1,-1,-1,-1,-1,-1,-1\] | 1        | 1        |
| 5   | \[0, 1, 2, 3, 4 \] | \[-1,-1,-1,-1,-1,-1,-1,-1\] | 1        | 2        |
| 5   | \[0, 1, 2, 3 \]    | \[-1,-1,-1,-1, 2,-1,-1,-1\] | 1        | 2        |
| 5   | \[0, 1, 2 \]       | \[-1,-1,-1, 2, 2,-1,-1,-1\] | 2        | 2        |
| 6   | \[0, 1, 2 \]       | \[-1,-1,-1, 2, 2, 1,-1,-1\] | 2        | 3        |
| 6   | \[0, 1 \]          | \[-1,-1, 1, 2, 2, 1,-1,-1\] | 2        | 3        |
| 6   | \[0, 1, 6\]        | \[-1,-1, 1, 2, 2, 1,-1,-1\] | 3        | 3        |

최종 결과는 -1, -1, 1, 2, 2, 1, -1, -1 이 된다.

**스텍에 저장하는 값은 무엇일까?** F(i)라고 생각하면 될 것 같다. 목적은 i번째 값 오른쪽에 있는 모든 값중 등장 횟수가 많은 값중 첫번째 값을 출력하는 거니까... 그러니까 while의 조건이 납득이간다. 스텍에서 5번값과 4번을 비교하고 조건에 맞으면 다시 5번과 3번을 비교하는 식이니까.
알고리즘을 공부하면서 for, while도 결국 반복되는 조건문이라는 것을 이해하고 (제어문이니까) 그것을 적절하게 조합해서 사용할 수 있어야겠다. 코테에서는 이게 stack인지 queue인지 안알려주니까 문제를 많이 풀어보고 감을 잡을 수밖에 없을 것 같다.
