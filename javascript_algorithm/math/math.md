# 수학

> 😎 : 풀었다. 내 풀이가 마음에 든다.
> 😗 : 풀긴 했지만 내 코드가 마음에 안든다.
> 🥲 : 어느정도 아이디어도 생각하고 풀어봤지만 결국 못풀었다.
> 😱 : 너무 어려웠다.

> 2022.02.14

수학은... 이름만 들어도 무섭다. 그런데 프로그래밍은 논리적 사고를 요구로 하는 것이 많다. 단서를 통해 답을 찾아나가는 것도 어떻게 보면 수학이다. 이번 문제는 그런 것은 아니지만 기초 수학 지식을 요구로 하고 있고 정리해야겠다.

## 수학 1

### 😎 [나머지](./boj%20math1/remaind.10430.js)

나머지 문제가 요구하는 것은 구현과 연산자의 논리 순서를 구분하는 문제다. 하지만 주어진 조건을 코드로 그릴수만 있다면 연산자의 논리 순서도 몰라도 된다. 그만큼 매우 쉬운 문제였다.

### 최대 공약수와 최소 공배수

> 😎 [최대공약수와 최소공배수](./boj%20math1/glcommonfactor.2609.js)  
> 🥲 [최소 공배수](./boj%20math1/greaterCommonFactor.1934.js)
> 참조 : [최대공약수와 최소공배수의 관계](https://mathbang.net/206)

최대 공약수와 최소 공배수 이론을 찾아봐야했다. 최대 공약수는 소수로 서로소가 나 올 때까지 두 수를 나눈 후 나눠준 수 만 모두 곱하면 구할 수 있다. 최소 공배수도 소수로 서로소가 나올때까지 나눠 나눠준 수와 서로소를 모두 곱하면 최소 공배수를 구할 수 있다. 최대 공약수나 최소 공배수를 알고 있으면 서로를 구할 수 있다.

1. 최대 공약수와 최소 공배수의 기본 내용.

```
A, B 최대 공약수는
   소수가 나올때까지 소수로 나눠서 나눠준 수를 곱한다.
   지수로 바꿔 최소 지수를 모아 곱한다.
```

```
A, B의 최소 공배수는
   소수가 나올때까지 소수로 나눠서 서로소와 나눠준 수를 모두 곱한다.
   지수는 모든 숫자와 지수가 가장 큰 값을 전부 곱한다.
```

```
L최소 공배수, G 최대 공약수, a, b는  A,B의 서로소

L = a \* b \* G
A * B / G = a * b * G
A \* B = a \* b \* G \* G = L / G
```

2. 유클리드 호제법
   말은 두 수가 서로(互) 상대방 수를 나누어(除)서 결국 원하는 수를 얻는 알고리즘을 나타낸다.
   2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a>b),
   a와 b의 최대공약수는 b와 r의 최대공약수와 같다.
   이 성질에 따라, b를 r로 나눈 나머지 r'를 구하고,
   다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때
   나누는 수가 a와 b의 최대공약수이다.

최소 공배수, 최소 공약수 문제는 유클리드 호제법을 사용해서 최대 공약수를 구한 다음에 최대 공약수와 최소 공배수와의 관계를 사용해 최소 공배수를 구할수 있다.

### 소수

> 😎 [소수 찾기](./boj%20math1/primnumber.1978.js)  
> 🥲 [소수 구하기](./boj%20math1/isPrime.1929.js)  
> 😱 [골드바흐의 추측](./boj%20math1/glodbachsconjecture.6588.js)

소수찾기, 소수구하기, 골드바흐의 추측은 소수를 판별하는 것을 알고 있다면 어렵지 않게 풀 수 있다. 소수 문제는 메모리와 시간 복잡도가 매우 제한되어있기 때문에 이것을 잘 고려해서 문제를 풀어야한다.

### 팩토리얼

> 😎 [팩토리얼](./boj%20math1/factorial.10872.js)  
> 🥲 [팩토리얼 0의 개수](./boj%20math1/factorialzero.1676.js)

### 순열과 조합

> 😱 [조합 0의 개수](./boj%20math1/combination.2004.js)
